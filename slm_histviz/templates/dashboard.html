{% extends 'layout.html' %}

{% block title %}Dashboard{% endblock %}

{% block script %}
    <script type="text/javascript">
    $(document).ready(function() {
        var $dpick = $('#timeline-datepicker');

        function getAccessBetweenDates(start_date, end_date) {
            var filters = {filters: [
                {and: [
                    {name: "created_at", op: "gte", val: start_date},
                    {name: "created_at", op: "lt", val: end_date},
                ]}
            ]};

            return $.get("/api/access_log", {results_per_page: 10000, q: JSON.stringify(filters)})
                .fail(function() {
                    console.error("Couldn't get access log data!");
                });
        }

        function bindComponentsToData(data) {
            var access_by_service = data['objects'].reduce((acc, cur) => {
                if (acc.hasOwnProperty(cur.sni)) {
                    acc[cur.sni].push(cur);
                } else {
                    acc[cur.sni] = [cur];
                }

                return acc;
            }, {});

            // for each service, we now coalesce the points into contiguous intervals within some threshold
            Object.keys(access_by_service).map(function(service) {
                var logs = access_by_service[service];

                access_by_service[service] = logs.reduce((acc, cur) => {
                    // for each point, extend the span if the previous point + 5sec <= current point
                    // if not, append this as a new entry
                    var last_entry = acc[acc.length-1];
                    if (!last_entry || moment(cur.created_at) > moment(last_entry.end_date)) {
                        // it's outside the previous span, create a mini-span of (time, time + 5sec)
                        acc.push({
                            start_date: moment(cur.created_at),
                            end_date: moment(cur.created_at).add(1, 'seconds')
                        })
                    }
                    else {
                        // it's within the previous span, so extend the last one
                        last_entry.end_date = moment(cur.created_at).add(1, 'seconds');
                    }

                    return acc;
                }, []);
            });

            console.log(access_by_service);

            var timelineData = Object.keys(access_by_service).map(function(service) {
                return {
                    label: service,
                    times: access_by_service[service].map((span) => {
                        return {
                            starting_time: span.start_date.toDate().valueOf(),
                            ending_time: span.end_date.toDate().valueOf(),
                        }
                    })
                }
            });

            // bind it to the timeline
            var chart = d3.timeline().stack().showToday().labelFormat(function(label){ return "P: " + label; });
            var svg = d3.select("#timeline")
                .append("svg")
                .attr("width", $("#timeline").parent().width())
                .datum(timelineData).call(chart);

            var colors = d3.scale.category20();

            var service_aggregate_data = Object.keys(access_by_service).map((service, idx) => {
                var total_time = access_by_service[service].reduce((running_total, cur) => {
                    return moment.duration(cur.end_date.diff(cur.start_date)).asSeconds() + running_total;
                }, 0);

                return {
                    "label": service,
                    "value": total_time,
                    "color": colors(idx)
                }
            });

            // create aggregates of the usage data and bind that to the donut
            makePie('time_usage_chart', service_aggregate_data);
        }

        var dates = [];

        // mask out dates in the datepicker for which we don't have data
        $.get("/api/data_dates").done(function(data) {
            dates = data['dates'].map((d) => moment.utc(d[0]));
            console.log("Dates: ", dates);
            // $dpick.datepicker('update');

            $dpick.datepicker({
                beforeShowDay: (d) => {
                    md = moment.utc(d);
                    // console.log(md);
                    return dates.some((cand) => cand.format('YYYY MM DD') == md.format('YYYY MM DD'))?"has-data":"";
                }
            })
            .on('changeDate', function(e) {
                console.log("Fetching for day ", moment.utc(e.date));

                var tomorrow = d3.time.day.offset(e.date, 1);
                // bind up the controls on the page
                getAccessBetweenDates(moment.utc(e.date).format("YYYY-MM-DD"), moment.utc(tomorrow).format("YYYY-MM-DD")).done(function(data) {
                    // populate the bits on the page
                    bindComponentsToData(data);
                })
            });

            // select the most recent date on which we have data
            $dpick.datepicker('setUTCDate', dates[dates.length-1].local().toDate());
        });
    });
    </script>
{% endblock %}


{% block style %}
    <style>
    .datepicker-days .has-data {
        background-color: yellow;
    }
    .date-selector {
        border-bottom: dotted 1px #ccc;
        padding: 5px;
        padding-bottom: 10px;
    }
    .date-selector label {
        font-weight: bold;
    }
    .dash {
        display: flex;
        flex-direction: column;
    }
    .dash .dash-panel {
        margin: 10px;
        padding: 10px;
        {# background: #ccc; #}
    }
    .timeline-summary-row {
        display: flex;
        flex: 0 0 350px;
    }
    .points-timeline {
        flex: 1 1;
        align-self: flex-end;
    }
    .interval-summary {
        flex: 0 0 350px;
        align-self: center;
        text-align: center;
    }
    .interval-details {
        flex: 1 1;
    }

    /* d3timeline styles */
    .axis path,
    .axis line {
      fill: none;
      stroke: black;
      shape-rendering: crispEdges;
    }
    .axis text {
      font-family: sans-serif;
      font-size: 10px;
    }
    .timeline-label {
      font-family: sans-serif;
      font-size: 12px;
    }
    #timeline2 .axis {
      transform: translate(0px,40px);
      -ms-transform: translate(0px,40px); /* IE 9 */
      -webkit-transform: translate(0px,40px); /* Safari and Chrome */
      -o-transform: translate(0px,40px); /* Opera */
      -moz-transform: translate(0px,40px); /* Firefox */
    }

    .coloredDiv {
      height:20px; width:20px; float:left;
    }
    </style>
{% endblock %}

{% block content %}
    <div class="date-selector">
        <!-- we'd select a date here somehow -->
        <label for="timeline-datepicker">show data for this date:</label> <input type="text" id="timeline-datepicker" />
    </div>

    <div id="dash-root"></div>

    <div class="dash">
        <div class="timeline-summary-row">
            <div class="dash-panel points-timeline">
                <!-- this is some kind of visualization of accesses to different services over time -->
                <div id="timeline"></div>
            </div>
            <div class="dash-panel interval-summary">
                <!-- this is a viz, possibly pie chart, that shows the proportion of services accessed (optionally including downtime) -->
                <div id="time_usage_chart"></div>
            </div>
        </div>

        <div class="dash-panel interval-details">
            <!-- this is a large table of every access in the selected region and its details -->
            {% include 'fragments/access_table.html' %}
        </div>
    </div>
{% endblock %}